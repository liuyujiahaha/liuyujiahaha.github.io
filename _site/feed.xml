<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>liuyujiahaha</title>
    <description>Max will build here weekly</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 29 Oct 2016 10:35:59 +0800</pubDate>
    <lastBuildDate>Sat, 29 Oct 2016 10:35:59 +0800</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>学习笔记之网络请求</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.不要同时打开太多的线程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1至3条线程即可，不要超过5条&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.线程概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主线程：UI线程，显示、刷新UI界面，处理UI控件的事件&lt;/li&gt;
  &lt;li&gt;子线程：后台线程，异步线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.不要把耗时的操作放在主线程，要放在子线程中执行&lt;/h4&gt;

&lt;h2 id=&quot;nsthread&quot;&gt;二、NSThread&lt;/h2&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.创建和启动线程的3中方式&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;先创建，后启动&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 创建
 	NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(download:) object:nil];
 // 启动
 [thread start];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建完自动启动&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [NSThread detachNewThreadSelector:@selector(download:) toTarget:self withObject:nil];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;隐式创建(自动启动)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [self performSelectorInBackground:@selector(download:) withObject:nil];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2.常见方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获取当前线程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (NSThread *)currentThread;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取主线程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (NSThread *)mainThread;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;睡眠(暂停)线程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (void)sleepUntilDate:(NSDate *)date;
 + (void)sleepForTimeInterval:(NSTimeInterval)ti;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置线程名字&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - (void)setName:(NSString *)n;
 - (NSString *)name;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;三、线程同步&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;实质：为了防止多个线程抢夺同一个资源造成的数据安全问题&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实现：给代码加一个互斥锁(同步锁)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @synchronized(self) {
 // 被锁住的代码
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gcd&quot;&gt;四、GCD&lt;/h3&gt;
&lt;p&gt;1.队列和任务&lt;/p&gt;

&lt;p&gt;1&amp;gt; 任务 ：需要执行什么操作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用block来封装任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2&amp;gt; 队列 ：存放任务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;全局的并发队列 ： 可以让任务并发执行
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自己创建的串行队列 ： 让任务一个接着一个执行
dispatch_queue_t queue = dispatch_queue_create(“cn.heima.queue”, NULL);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主队列 ： 让任务在主线程执行
dispatch_queue_t queue = dispatch_get_main_queue();&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.执行任务的函数&lt;/p&gt;

&lt;p&gt;1&amp;gt; 同步执行 : 不具备开启新线程的能力
dispatch_sync…&lt;/p&gt;

&lt;p&gt;2&amp;gt; 异步执行 : 具备开启新线程的能力
dispatch_async…&lt;/p&gt;

&lt;p&gt;3.常见的组合&lt;/p&gt;

&lt;p&gt;1&amp;gt; dispatch_async + 全局并发队列
2&amp;gt; dispatch_async + 自己创建的串行队列&lt;/p&gt;

&lt;p&gt;4.线程间的通信&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
	// 执行耗时的异步操作...
	dispatch_async(dispatch_get_main_queue(), ^{
   // 回到主线程，执行UI刷新操作
	});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.GCD的所有API都在libdispatch.dylib，Xcode会自动导入这个库&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主头文件 ： #import &amp;lt;dispatch/dispatch.h&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.延迟执行&lt;/p&gt;

&lt;p&gt;1&amp;gt; perform….&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 3秒后自动回到当前线程调用self的download:方法，并且传递参数：@&quot;http://555.jpg&quot;
[self performSelector:@selector(download:) withObject:@&quot;http://555.jpg&quot; afterDelay:3];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2&amp;gt; dispatch_after…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 任务放到哪个队列中执行
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
double delay = 3; // 延迟多少秒
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
// 3秒后需要执行的任务
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.一次性代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
// 这里面的代码，在程序运行过程中，永远只会执行1次
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 28 Oct 2016 13:40:30 +0800</pubDate>
        <link>http://localhost:4000/blog/nsthread/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/nsthread/</guid>
        
        <category>iOS</category>
        
        <category>GCD</category>
        
        <category>NSThread</category>
        
        
        <category>Front-end</category>
        
      </item>
    
      <item>
        <title>Ice Bear Jekyll Theme</title>
        <description>&lt;p&gt;This is my first jekyll theme decorated by my favorite items – blue and ice bear. It’s welcomed to give me a star at github if you like it.&lt;/p&gt;

&lt;p&gt;&lt;a class=&quot;github-button&quot; href=&quot;https://github.com/songkong/Blog/tree/gh-pages&quot; data-count-href=&quot;/songkong/Blog/stargazers&quot; data-count-api=&quot;/repos/songkong/Blog#stargazers_count&quot; data-count-aria-label=&quot;# stargazers on GitHub&quot; aria-label=&quot;Star songkong/Blog on GitHub&quot;&gt;Star&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;installation&quot;&gt;Installation&lt;/h1&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Fork the repository. &lt;a class=&quot;github-button&quot; href=&quot;https://github.com/songkong/Blog/fork&quot; data-count-href=&quot;/songkong/Blog/network&quot; data-count-api=&quot;/repos/songkong/Blog#forks_count&quot; data-count-aria-label=&quot;# forks on GitHub&quot; aria-label=&quot;Fork songkong/Blog on GitHub&quot;&gt;Fork&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Edit &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; file.&lt;/li&gt;
  &lt;li&gt;Edit &lt;code class=&quot;highlighter-rouge&quot;&gt;About me&lt;/code&gt; content in &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Add your own &lt;code class=&quot;highlighter-rouge&quot;&gt;projects&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;_includes/projects.html&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Change &lt;code class=&quot;highlighter-rouge&quot;&gt;domain name&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Add your own &lt;code class=&quot;highlighter-rouge&quot;&gt;disqus&lt;/code&gt; code in &lt;code class=&quot;highlighter-rouge&quot;&gt;_includes/comments.html&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The last two scripts in &lt;code class=&quot;highlighter-rouge&quot;&gt;assets/js/script.js&lt;/code&gt; offer Google Analytics and Baidu Analytics. You can replace them with your own codes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;style-test&quot;&gt;Style test&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;heading-1&quot;&gt;Heading 1&lt;/h1&gt;

&lt;h2 id=&quot;heading-2&quot;&gt;Heading 2&lt;/h2&gt;

&lt;h3 id=&quot;heading-3&quot;&gt;Heading 3&lt;/h3&gt;

&lt;h4 id=&quot;heading-4&quot;&gt;Heading 4&lt;/h4&gt;

&lt;h5 id=&quot;heading-5&quot;&gt;Heading 5&lt;/h5&gt;

&lt;h6 id=&quot;heading-6&quot;&gt;Heading 6&lt;/h6&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;heading-3-in-blockquotes&quot;&gt;Heading 3 in Blockquotes&lt;/h3&gt;
  &lt;p&gt;Normal Blockquotes text.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Unordered List in Blockquotes.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;ol&gt;
    &lt;li&gt;Ordered List in Blockquotes.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Unordered List.
    &lt;ul&gt;
      &lt;li&gt;Unordered List.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Ordered List
    &lt;ol&gt;
      &lt;li&gt;Ordered List&lt;/li&gt;
      &lt;li&gt;Ordered List&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Ordered List&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ruby&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;codes&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'parallel'&lt;/span&gt;

&lt;span class=&quot;no&quot;&gt;Parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lots_of_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;heavy_computation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Sat, 01 Oct 2016 15:52:30 +0800</pubDate>
        <link>http://localhost:4000/blog/ice-bear-jekyll-theme/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/ice-bear-jekyll-theme/</guid>
        
        <category>EN</category>
        
        <category>jekyll</category>
        
        <category>front-end</category>
        
        
        <category>Front-end</category>
        
      </item>
    
      <item>
        <title>学习笔记之《JavaScript 高级程序设计》（上篇）</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;javascriptchapter1-&quot;&gt;第一章【 &lt;a href=&quot;#chapter1&quot;&gt;JavaScript简介&lt;/a&gt; 】&lt;/h4&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;#chapter1-1&quot;&gt;ECMAScript&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#chapter1-2&quot;&gt;文档对象模型（DOM）&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#chapter1-3&quot;&gt;浏览器对象模型（BOM）&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;chapter1&quot;&gt;第一章  JavaScript简介&lt;/h3&gt;

&lt;p&gt;一个完整的 JavaScript 实现由如下三个部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;核心（ECMAJavaScript）&lt;/li&gt;
  &lt;li&gt;文档对象模型（DOM）&lt;/li&gt;
  &lt;li&gt;浏览器对象模型（BOM）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;chapter1-1&quot;&gt;1.1 ECMAScript&lt;/h4&gt;

&lt;p&gt;ECMAScript 是由 ECMA-262 定义的与&lt;code class=&quot;highlighter-rouge&quot;&gt;宿主环境&lt;/code&gt;（如 Web 浏览器、Node 和 Adobe Flash 等）没有依赖关系的一门语言，该语言本身并不包括输入和输出定义。宿主环境不仅提供基本的 ECMAScript 实现，同时还会提供该语言的扩展，如 DOM。&lt;/p&gt;

&lt;p&gt;ECMA-262 规定了这门语言的下列组成：语法、类型、语句、关键字、保留字、操作符、对象。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;chapter1-2&quot;&gt;1.2 文档对象模型（DOM）&lt;/h4&gt;

&lt;p&gt;文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的 API。 DOM 把整个页面映射为一个多层节点结构，HTML 或 XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。通过 DOM 创建的文档树形图并借助 DOM 提供的 API，可以轻松的对节点进行删除、添加、替换或修改等操作。&lt;/p&gt;

&lt;p&gt;由于 Netscape 和微软在开发 DHTML 方面持不同意见，这影响了 Web 跨平台性能。于是，W3C 开始着手规划 DOM。1998 年 DOM1 级（DOM Level 1）成为 W3C 的推荐标准。DOM1 级由两个模块组成：DOM 核心（DOM Core）和 DOM HTML。其中 DOM 核心规定了如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块在 DOM 核心基础上添加了针对 HTML 的对象和方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DOM 并不只是针对 JS，很多别的语言也实现了 DOM。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DOM2 级引入了如下新模块：DOM 视图（DOM Views）、DOM 事件（DOM Events）、DOM 样式（DOM Style）和 DOM 遍历和范围（DOM Traversal and Range）。&lt;/p&gt;

&lt;p&gt;DOM3 级在 DOM 加载和保存（DOM Load and Save）模块中引入了以统一方式加载和保存文档的方法，在 DOM 验证（DOM Validation）模块中新增了验证文档的方法。同时 DOM3 级也开始支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：DOM0 级标准是不存在的，只是 DOM 历史坐标中的一个参照点。具体来说，它指的是 IE 4.0 和 Netscape Navigator 4.0 最初支持的 DHTML。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了 DOM 核心和 DOM HTML 接口之外，另外几种语言也发布了针对自己的 DOM 标准。以下基于 XML 的语言，它们的 DOM 标准都添加了与特定语言相关的新方法和新接口，且这些语言都是 W3C 的推荐标准：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SVG （Scalable Vector Graphic，可伸缩矢量图）1.0；&lt;/li&gt;
  &lt;li&gt;MathML（Mathematical Markup Language，数学标记语言）1.0；&lt;/li&gt;
  &lt;li&gt;SMIL（Synchronized Multimedia Integration Language，同步多媒体集成语言）。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;chapter1-3&quot;&gt;1.3 浏览器对象模型（BOM）&lt;/h4&gt;

&lt;p&gt;浏览器对象模型（BOM，Browser Object Model）提供访问和操作浏览器窗口的方法和接口。使用 BOM 可以控制浏览器显示的页面以外的部分。由于没有 BOM 标准可以遵循，因此每个浏览器都有自己的实现。&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Sep 2016 13:40:30 +0800</pubDate>
        <link>http://localhost:4000/blog/javascript-reading-notes/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/javascript-reading-notes/</guid>
        
        <category>CN</category>
        
        <category>front-end</category>
        
        <category>JavaScript</category>
        
        
        <category>Front-end</category>
        
      </item>
    
      <item>
        <title>学习笔记之网络请求</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.不要同时打开太多的线程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1至3条线程即可，不要超过5条&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.线程概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主线程：UI线程，显示、刷新UI界面，处理UI控件的事件&lt;/li&gt;
  &lt;li&gt;子线程：后台线程，异步线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.不要把耗时的操作放在主线程，要放在子线程中执行&lt;/h4&gt;

&lt;h2 id=&quot;nsthread&quot;&gt;二、NSThread&lt;/h2&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.创建和启动线程的3中方式&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;先创建，后启动&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 创建
 	NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(download:) object:nil];
 // 启动
 [thread start];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建完自动启动&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [NSThread detachNewThreadSelector:@selector(download:) toTarget:self withObject:nil];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;隐式创建(自动启动)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [self performSelectorInBackground:@selector(download:) withObject:nil];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2.常见方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获取当前线程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (NSThread *)currentThread;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取主线程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (NSThread *)mainThread;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;睡眠(暂停)线程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (void)sleepUntilDate:(NSDate *)date;
 + (void)sleepForTimeInterval:(NSTimeInterval)ti;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置线程名字&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - (void)setName:(NSString *)n;
 - (NSString *)name;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;三、线程同步&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;实质：为了防止多个线程抢夺同一个资源造成的数据安全问题&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实现：给代码加一个互斥锁(同步锁)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @synchronized(self) {
 // 被锁住的代码
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gcd&quot;&gt;四、GCD&lt;/h3&gt;
&lt;p&gt;1.队列和任务&lt;/p&gt;

&lt;p&gt;1&amp;gt; 任务 ：需要执行什么操作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用block来封装任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2&amp;gt; 队列 ：存放任务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;全局的并发队列 ： 可以让任务并发执行
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自己创建的串行队列 ： 让任务一个接着一个执行
dispatch_queue_t queue = dispatch_queue_create(“cn.heima.queue”, NULL);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主队列 ： 让任务在主线程执行
dispatch_queue_t queue = dispatch_get_main_queue();&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.执行任务的函数&lt;/p&gt;

&lt;p&gt;1&amp;gt; 同步执行 : 不具备开启新线程的能力
dispatch_sync…&lt;/p&gt;

&lt;p&gt;2&amp;gt; 异步执行 : 具备开启新线程的能力
dispatch_async…&lt;/p&gt;

&lt;p&gt;3.常见的组合&lt;/p&gt;

&lt;p&gt;1&amp;gt; dispatch_async + 全局并发队列
2&amp;gt; dispatch_async + 自己创建的串行队列&lt;/p&gt;

&lt;p&gt;4.线程间的通信&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
	// 执行耗时的异步操作...
	dispatch_async(dispatch_get_main_queue(), ^{
   // 回到主线程，执行UI刷新操作
	});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.GCD的所有API都在libdispatch.dylib，Xcode会自动导入这个库&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主头文件 ： #import &amp;lt;dispatch/dispatch.h&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.延迟执行&lt;/p&gt;

&lt;p&gt;1&amp;gt; perform….&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 3秒后自动回到当前线程调用self的download:方法，并且传递参数：@&quot;http://555.jpg&quot;
[self performSelector:@selector(download:) withObject:@&quot;http://555.jpg&quot; afterDelay:3];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2&amp;gt; dispatch_after…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 任务放到哪个队列中执行
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
double delay = 3; // 延迟多少秒
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
// 3秒后需要执行的任务
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.一次性代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
// 这里面的代码，在程序运行过程中，永远只会执行1次
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 15 Sep 2016 13:40:30 +0800</pubDate>
        <link>http://localhost:4000/blog/nsthread/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/nsthread/</guid>
        
        <category>CN</category>
        
        <category>front-end</category>
        
        
        <category>Front-end</category>
        
      </item>
    
  </channel>
</rss>
